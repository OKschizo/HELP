"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9691,703],{703:function(t,e,a){a.d(e,{db:function(){return n}});var s=a(69584),l=a(28239),o=a(44492);let c={apiKey:o.env.NEXT_PUBLIC_FIREBASE_API_KEY,authDomain:o.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,projectId:o.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,storageBucket:o.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,messagingSenderId:o.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,appId:o.env.NEXT_PUBLIC_FIREBASE_APP_ID},i=0===(0,s.C6)().length?(0,s.ZF)(c):(0,s.C6)()[0],n=(0,l.ad)(i);e.Z=i},59691:function(t,e,a){a.d(e,{UserDatabase:function(){return o}});var s=a(28239),l=a(703);class o{static async getOrCreateUser(t){let e=t.toLowerCase(),a=(0,s.collection)(l.db,"users"),o=(0,s.query)(a,(0,s.where)("walletAddress","==",e)),c=await (0,s.getDocs)(o);if(!c.empty){let t=c.docs[0];return{id:t.id,...t.data()}}let i={walletAddress:e,createdAt:s.EK.now(),updatedAt:s.EK.now()};return{id:(await (0,s.ET)(a,i)).id,...i}}static async updateUserProfile(t,e){let a=(0,s.JU)(l.db,"users",t);await (0,s.r7)(a,{profile:e,updatedAt:s.EK.now()})}static async getUserCollections(t){let e=(0,s.collection)(l.db,"collections"),a=(0,s.query)(e,(0,s.where)("userId","==",t));return(await (0,s.getDocs)(a)).docs.map(t=>({id:t.id,...t.data()}))}static async createCollection(t,e,a){let o=a.contractAddress?String(a.contractAddress).toLowerCase():void 0;if(o){let e=(0,s.collection)(l.db,"collections"),a=(0,s.query)(e,(0,s.where)("userId","==",t),(0,s.where)("contractAddress","==",o)),c=await (0,s.getDocs)(a);if(!c.empty){let t=c.docs[0];return{id:t.id,...t.data()}}}let c={...a,...o?{contractAddress:o}:{},userId:t,walletAddress:e.toLowerCase(),stats:{totalMinted:0,totalRevenue:"0",uniqueHolders:0},bannerImageUrl:"",avatarImageUrl:"",categories:[],headerImageUrl:"",thumbnailUrl:"",shareOnExplore:!1,createdAt:s.EK.now(),updatedAt:s.EK.now()},i=(0,s.collection)(l.db,"collections");return{id:(await (0,s.ET)(i,c)).id,...c}}static async updateCollection(t,e){let a=(0,s.JU)(l.db,"collections",t);await (0,s.r7)(a,{...e,updatedAt:s.EK.now()})}static async updateCollectionByContractAddress(t,e){let a=await o.findCollectionByContractAddress(t);if(!a)throw Error("Collection not found for contract address");await o.updateCollection(a.id,e)}static async findCollectionByContractAddress(t){let e=(0,s.collection)(l.db,"collections"),a=await (0,s.getDocs)((0,s.query)(e,(0,s.where)("contractAddress","==",t.toLowerCase())));if(a.empty&&(a=await (0,s.getDocs)((0,s.query)(e,(0,s.where)("contractAddress","==",t)))),a.empty)return null;let o=a.docs[0];return{id:o.id,...o.data()}}static async addAllowlistRound(t,e){let a=(0,s.JU)(l.db,"collections",t),o=(0,s.JU)((0,s.collection)(a,"allowlists"),e.id),c=(0,s.JU)((0,s.collection)(a,"allowlists"),"".concat(e.id,"-addresses")),i={id:e.id,name:e.name,root:e.root,size:e.size,priceWei:e.priceWei||"0",createdAt:s.EK.now(),updatedAt:s.EK.now()};"number"==typeof e.maxPerWallet&&(i.maxPerWallet=e.maxPerWallet),"number"==typeof e.maxPerTx&&(i.maxPerTx=e.maxPerTx),e.startsAt&&(i.startsAt=s.EK.fromDate(e.startsAt)),e.endsAt&&(i.endsAt=s.EK.fromDate(e.endsAt)),await (0,s.pl)(o,i),await (0,s.pl)(c,{addresses:e.addresses.map(t=>t.toLowerCase()),updatedAt:s.EK.now()})}static async deleteAllowlistRound(t,e){let a=(0,s.JU)(l.db,"collections",t);await (0,s.oe)((0,s.JU)((0,s.collection)(a,"allowlists"),e)),await (0,s.oe)((0,s.JU)((0,s.collection)(a,"allowlists"),"".concat(e,"-addresses")))}static async setCurrentAllowlist(t,e){await o.updateCollection(t,{currentAllowlistId:e})}static async getAllowlistAddresses(t,e){let a=(0,s.JU)(l.db,"collections",t),o=(0,s.JU)((0,s.collection)(a,"allowlists"),"".concat(e,"-addresses")),c=await (0,s.QT)(o);if(!c.exists())return[];let i=c.data();return Array.isArray(i.addresses)?i.addresses:[]}static async listAllowlistRounds(t){let e=(0,s.JU)(l.db,"collections",t),a=await (0,s.getDocs)((0,s.collection)(e,"allowlists")),o=[];return a.forEach(t=>{let e=t.data();e&&e.root&&e.id&&o.push(e)}),o}static async getAllowlistMeta(t,e){let a=(0,s.JU)(l.db,"collections",t),o=(0,s.JU)((0,s.collection)(a,"allowlists"),e),c=await (0,s.QT)(o);return c.exists()?c.data():null}static async getCollection(t){let e=(0,s.JU)(l.db,"collections",t),a=await (0,s.QT)(e);return a.exists()?{id:a.id,...a.data()}:null}static async deleteCollection(t){let e=(0,s.JU)(l.db,"collections",t);await (0,s.oe)(e)}static async updateCollectionDeployment(t,e){let a=(0,s.JU)(l.db,"collections",t);await (0,s.r7)(a,{deployment:e,status:"deployed",updatedAt:s.EK.now()})}static async updateCollectionStats(t,e){let a=(0,s.JU)(l.db,"collections",t);await (0,s.r7)(a,{stats:e,updatedAt:s.EK.now()})}}},69584:function(t,e,a){a.d(e,{C6:function(){return s.C6},ZF:function(){return s.ZF}});var s=a(61214);/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */(0,s.KN)("firebase","12.2.1","app")}}]);